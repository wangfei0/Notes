---
typora-copy-images-to: images
---

# 项目难点回答

1. 事务注解@Transactional的情况下。在Controller层加了这个

   说这个就要知道这个注解的源码，实现原理

# 商城项目

## 简介

基于SSM搭建的一个商城后台管理系统

## 技术点

1. #### 用户SSO单点登录实现

   - SSO单点登录的理解：

     全称是Single Sign On，SSO指的是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

     相关文章：https://zhuanlan.zhihu.com/p/121084223

   - 解决方式：使用redis实现session共享

     - 用户第一次登录时，web容器会生成session，并且将sessionId写入到名为JSESSIONID的cookie中，浏览器存储该cookie，并且在下次请求时带上该cookie，服务器收到请求，拿到cookie，然后去查找对应id的session，进行验证是否是同一个用户。

       该Cookie为服务器自动生成的，它的maxAge属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。

       HttpSession的源码解析

       [文章1](https://blog.csdn.net/securitit/article/details/108046250?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242)

       [文章2](https://blog.csdn.net/hanziang1996/article/details/78969044?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)
     
     - 项目中是拿到httpsession，获取该session的id存入自定义的一个cookie中，并将这个cookie存储到浏览器。同时，将这个sessionid作为key值，接口获取到的用户信息进行序列化为String后，存入到redis缓存中；
     
     - 用户操作时，每个请求都会带上我们设置的cookie，如果没有指定名称的cookie就转到登录页面，拿到sessionid之后去redis查询结果，如果查不到就转到登录页面，能查到就是用户已经登录；
     
     - 项目中的共享session还设置了过期时间，默认是60分钟，同时设置了过滤器，更新session的过期时间；
     
       ~~~xml
           <!--二期新增重置session时间的Filter-->
           <filter>
               <filter-name>sessionExpireFilter</filter-name>
               <filter-class>com.mmall.controller.common.SessionExpireFilter</filter-class>
           </filter>
           <filter-mapping>
               <filter-name>sessionExpireFilter</filter-name>
               <url-pattern>*.do</url-pattern>
           </filter-mapping>
       ~~~
     
       ~~~java
       public class SessionExpireFilter implements Filter {
       
           @Override
           public void init(FilterConfig filterConfig) throws ServletException {
       
           }
       
           @Override
           public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
               HttpServletRequest httpServletRequest = (HttpServletRequest) request;
               String loginToken = CookieUtil.readLoginToken(httpServletRequest);
               if (StringUtils.isNotEmpty(loginToken)){
                   String userJsonStr = RedisShardedPoolUtil.get(loginToken);
                   User user = JsonUtil.string2Obj(userJsonStr, User.class);
                   if (user != null){
                       RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME);
                   }
               }
               chain.doFilter(request, response);
           }
       
           @Override
           public void destroy() {
       
           }
       }
       ~~~
     
       
   
2. #### 全局异常处理

   推荐查看文章

   [简单使用文章](https://blog.csdn.net/qq_22172133/article/details/82147630)

   [源码解析文章](https://blog.csdn.net/pfnie/article/details/52416943?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param)

   [另一篇详细介绍的文章](https://www.cnblogs.com/linkstar/p/6699697.html)

   [最新的在spring与springboot中都有了新的异常处理的方法](https://www.cnblogs.com/linkstar/p/8520027.html)

   - **在这个项目里的解决方法**

     自定义异常处理类，实现HandlerExceptionResolver，重写resolveException()方法

     ~~~java 
     @Component
     public class ExceptionResolver implements HandlerExceptionResolver {
         @Override
         public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
             log.error("访问{}发生错误, 错误信息:{}",httpServletRequest.getRequestURI(),e.getMessage());
             ModelAndView modelAndView = new ModelAndView(new MappingJackson2JsonView());
             //当使用是jackson2.x的时候使用MappingJackson2JsonView，课程中使用的是1.9。
             modelAndView.addObject("status",ResponseCode.ERROR.getCode());
             modelAndView.addObject("msg","接口异常,详情请查看服务端日志的异常信息");
             modelAndView.addObject("data",e.toString());
             return modelAndView;
         }
     }
     ~~~

     **注意：** 要加上@Component或者在xml文件里配置<bean>标签，将这个类作为bean注册到IOC容器中；

   - **最新的方法**

     [使用两个注解的方法](https://blog.csdn.net/kinginblue/article/details/70186586)

     [使用两个注解方法的源码解析](https://juejin.im/post/6844903815859322893)
     
     使用的是：@ControllerAdvice 、@ExceptionHandler通过这两个注解来实现全局的异常捕获
     
     @ControllerAdvice 标注在类上
     
     @ExceptionHandler 标注在异常处理方法上
     
     [实现原理](https://blog.csdn.net/andy_zhang2007/article/details/100154082)
     
     ~~~Java
     @ControllerAdvice
     public class GlobalExceptionHandler {
     
         @ExceptionHandler(Exception.class)
         @ResponseBody
         String handleException(){
             return "Exception Deal!";
         }
     }
     ~~~
     
     #### **异常处理的原理**
     
     1. 首先，`ExceptionHandlerExceptionResolver`是`Spring MVC`缺省被启用的一个`HandlerExceptionResolver`,它会被作为一个组合模式`HandlerExceptionResolver bean`中的一个元素进入到`bean`容器中。`ExceptionHandlerExceptionResolver`实现了接口`InitializingBean`,所以它在实例化时会被初始化。该过程中，它就会搜集所有的`@ControllerAdvice`注解类中使用`@ExceptionHandler`定义的异常处理控制器方法以供随后工作时使用。
     2. 接下来，`DispatcherServlet`初始化时，会搜集所有`HandlerExceptionResolver bean`记录到自己的策略组件属性`List<HandlerExceptionResolver> handlerExceptionResolvers`。
     
     3. 请求进入DispatcherServlet的doDispatch方法
     
     ~~~java 
     	protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
     				...
     				//处理controller方法
     				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
      
     				...
     			}
     			catch (Exception ex) {
     				dispatchException = ex;
     			}
     			catch (Throwable err) {
     				dispatchException = new NestedServletException("Handler dispatch failed", err);
     			}
     			//异常处理中心
     			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
     		}
     		...
     	}
     ~~~
     
     4. 从doDispatch方法中可以看出，程序先处理了controller层的业务逻辑，对于业务逻辑抛出的异常，程序统一做了封装，然后进入了processDispatchResult方法中进行处理。
     
     ~~~Java
     	// DispatcherServlet 代码片段，
         // 在 HandlerAdaptor 执行 Handler 之后调用，
         // 如果之前的逻辑有异常，则 exception 不为 null，
         // 如果之前的逻辑执行正常， 则 exception 为 null
     private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
     			@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
     			@Nullable Exception exception) throws Exception {
     
     		boolean errorView = false;
     
     		//如果程序发生了异常，就进行处理
     		if (exception != null) {
     			if (exception instanceof ModelAndViewDefiningException) {
     				logger.debug("ModelAndViewDefiningException encountered", exception);
     				mv = ((ModelAndViewDefiningException) exception).getModelAndView();
     			}
     			else {
     				Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
                     // 这里视图处理该异常：
                     // 1. 内部将其完全处理
                     // 2. 或者返回一个用于渲染错误的数据模型和视图
     				mv = processHandlerException(request, response, handler, exception);
     				errorView = (mv != null);
     			}
     		}
     		...
     	}
     	//调用这个方法
     	protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
     			@Nullable Object handler, Exception ex) throws Exception {
     
     		// Success and error responses may use different content types
     		request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
     
     		// Check registered HandlerExceptionResolvers...
     		ModelAndView exMv = null;
     		if (this.handlerExceptionResolvers != null) {
     		    //遍历handlerExceptionResolvers处理异常信息
                 // 遍历`handlerExceptionResolvers`中每个`HandlerExceptionResolver`对象
                 // 试图对异常 ex 进行处理
     			for (HandlerExceptionResolver resolver : this.handlerExceptionResolvers) {
                     //调用异常处理方法
     				exMv = resolver.resolveException(request, response, handler, ex);
     				if (exMv != null) {
     					break;
     				}
     			}
     		}
     		...
     	}
     ~~~
     
     5. 这里，轮到`ExceptionHandlerExceptionResolver`处理异常时，`#resolveException`最终会调用`ExceptionHandlerExceptionResolver#doResolveHandlerMethodException`。该处理过程主要步骤如下 ：
     
        1. 找到能处理该异常的控制器方法 
     
           ```java
           ExceptionHandlerExceptionResolver#getExceptionHandlerMethod
           ```
     
           1. 先从发生异常的控制器方法所在类查找是否存在使用注解`@ExceptionHandler`并能处理该异常的方法;
           2. 如果找不到，从所有`@ControllerAdvice`注解类中查找使用注解`@ExceptionHandler`并能处理该异常的方法;
     
        2. 执行处理该异常的控制器方法处理该异常；
     
     6. 至此，整个的全局异常处理方法全部完成。

3. #### 通用响应对象设计

   就是自定义了一个类，这个类包含了三个字段，code，message，以及使用泛型定义的data。

   在这个类里重载了一些构造方法，同于创建不同类型的响应。

   其响应状态码与状态信息由枚举类定义。

   ~~~java
   public class ServerResponse<T> implements Serializable {
       private int status;
       private String msg;
       private T data;
   }
   ~~~

   枚举类

   像静态变量一样，加载类的时候就创建了枚举类实例。如ResponseCode.SUCCESS。

   通过getValue()方法获取枚举类实例的值。

   ~~~Java
   public enum ResponseCode {
   
       SUCCESS(0,"SUCCESS"),
       ERROR(1,"ERROR"),
       NEED_LOGIN(10,"NEED_LOGIN"),
       ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT");
   
       private final int code;
       private final String desc;
   
       ResponseCode(Integer code, String desc) {
           this.code = code;
           this.desc = desc;
       }
   
       public Integer getCode() {
           return code;
       }
   
       public String getDesc() {
           return desc;
       }
   }
   ~~~

   

   在其中重载了一些方法，用于实现针对不同返回状态的不同响应数据，比如错误和成功状态的情况下会通过不同的方法设置不同的状态码和状态信息；

   

4. #### 多tomcat部署，使用redis实现分布式锁

   - 项目中使用了两个tomcat进行部署测试。
   - 使用分布式锁的目的是为了解决定时关闭订单任务的单次运行，避免多线程同时执行关闭订单任务；

   分布式锁的具体实现：

   ​	定时任务使用的是springScheduled定时任务注解。[解析](https://www.cnblogs.com/knightsu/p/9428495.html)

   ​	使用到了cron表达式

   ~~~java
       /**
        * 定时任务，版本3
        *
        * 基于redis的分布式锁实现，防止死锁
        *
        */
       @Scheduled(cron = "0 */1 * * * ?")//(每个1分钟的整数倍执行)
       public void closeOrderTaskV3() {
           log.info("关闭订单定时任务启动");
           long  lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout","5000"));
           //分布式锁实现
           Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+lockTimeout));
           if (setnxResult != null && setnxResult == 1){
               //如果返回值是1，代表设置成功，获取锁
               closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);
           }else {
               //没有获取到锁，继续判断，根据value值中的时间戳，看是否可以重置并获取到锁
               String localValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);
               if (localValueStr != null && System.currentTimeMillis()>Long.parseLong(localValueStr)){
                   //锁已失效
                   //获取锁，并重新设置超时时间
                   String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));
                   //再次用当前时间戳getset
                   //返回给定的key的旧值，旧值判断，是否可以获取锁
                   //当key没有旧值，即key不存在时，返回nil，获取锁
                   //这里我们set了一个新的value值，获取旧的值
                   if(getSetResult == null || (getSetResult != null && StringUtils.equals(getSetResult,localValueStr))){
                       //真正获取到锁
                       closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);
                   }else {
                       log.info("没有获得分布式锁：{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);
                   }
               }else {
                   log.info("没有获得分布式锁：{}",Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);
               }
           }
           log.info("关闭订单定时任务结束");
       }
   ~~~

   **解释：** 首先通过jedis连接池的setnx（）方法尝试获取锁，即尝试去存储一个key和value值。

   当返回为1时，代表设置成功，可以执行目标方法。

   当返回为0时代表设置失败。

   **设置失败的操作有一个防止产生死锁的操作**，就是防止上一个线程执行之后没有删除分布式锁导致以后都拿不到分布式锁产生的死锁问题。

   解决方法就是，在redis中的分布式锁的value值存放的是一个时间戳，这个时间戳是设置分布式锁的时间加上5秒的时间。当分布式锁获取失败后，会去拿到这个分布式锁，获取这个时间戳，拿这个时间戳与当前系统时间进行比较，如果当前系统时间是大于获取到的时间戳的话，代表锁已经过期，可以重新设置分布式锁。那么就会进行分布式锁重设之后拿到分布式锁，执行目标方法。如果当前系统时间是不大于获取到的时间戳的话，就代表分布式锁没有过期，只是真的没拿到分布式锁。

   同时为了进一步防止死锁，在目标方法内加入了设置锁过期时间，以及方法结束前删除分布式锁的操作。

   

5. #### 权限拦截器设计，用于拦截管理界面的接口

   使用springMVC拦截器，实现HandlerInterceptor接口，重写preHandle方法，当preHandle返回true时才执行controller方法，否则不执行controller方法；

   springmvc配置文件配置如下

   ~~~xml
       <!--springMVC拦截器设置-->
       <mvc:interceptors>
           <!--定义在这里的所有的都会拦截-->
           <mvc:interceptor>
               <mvc:mapping path="/manage/**"/>
               <!--排除不走拦截器的请求路径-->
               <!--<mvc:exclude-mapping path="/manage/user/login.do"/>-->
               <bean class="com.mmall.controller.common.interceptor.AuthorityInterceptor"></bean>
           </mvc:interceptor>
       </mvc:interceptors>
   ~~~

   实现HandlerInterceptor接口的类实现

   ~~~java
   public class AuthorityInterceptor implements HandlerInterceptor{
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           //判断权限代码
           //todo
           //handlerMethod.getMethodAnnotation()
           //这里可以通过方法拿到方法上的注解，像权限项目一样，获取到注解里的内容，然后查询数据库中用户对应角色的权限字符串里有没有注解上需要的权限字符串，如果有就是有权限们继续执行，
           //如果没有，抛出自定义的无权限异常，通过全局异常处理返回给前端进行提示。
           
       }
   }
   ~~~

6. #### 事务注解的使用与原理

   @Transactional注解，标注在controller上
   
   //todo源码要看一下啊
   
   配置文件开启注解事务
   
   ~~~xml
   <tx:annotation-driven/>
   ~~~
   
   这个注解有很多参数可以指定
   
   注意避免注解失效
   
   首先是传播行为的参数，有三个会不使用事务，还有要指定rollbackfor参数的值，默认只对RuntimeException和error进行异常处理。想对非运行异常也回滚就要指定为Exception.class
   
   

## 面试问题

1. 响应对象怎么设计的，里面都有什么？

   自定义了一个类。包括code,message,data。

2. 全局异常处理怎么设计的？

   见上文介绍。

3. 事务注解的实现原理了解吗，事务注解配置属性怎么生效的？https://blog.csdn.net/weixin_43155866/article/details/108996323

4. 横向越权是什么？什么场景下出现？

   **场景**

   1.横向越权可能出现的场景有：在用户忘记密码重置密码时，回答对了问题进入密码重置阶段时，如果知道其他用户的用户名，很容易改变此用户的密码，然后就可以进行越权访问了。

   ​	为了避免以上横向越权的行为，常用办法是在用户回答密码提示问题正确后，服务端随机生成一个Token值返回，并给Token设置过期时间（如30分钟），然后重置密码的接口中要求前端传递该Token，即可确保是当前用户修改自己的密码了。

   2.收货地址模块中对收货地址进行删除/更新/查询时产生。

   如：删除

   ~~~Java
      public ServerResponse<String> delete(Integer userId, Integer shippingId) {
           //直接调用Mybatis的deleteByPrimaryKey()方法
           int rowCount = shippingMapper.deleteByPrimaryKey(shippingId);
           if (rowCount > 0) {
               return ServerResponse.createBySuccessMessage("删除地址成功");
           }
           return ServerResponse.createByErrorMessage("删除地址失败");
       }
   ~~~

   ​	只用shippingId删除的话，就会出现其他人拿到接口，更改参数，直接删除收货地址的问题。

   ​	**解决：**

   ​	同时使用userid和shippingId才能修改用户对应的地址，userId不会暴漏给外界的，是发请求后根据用户名获取用户信息，拿到用户ID，再调用这个DAO层的方法的。

   ​	**更新** 类似于删除操作。

5. （可能会问）redis怎么实现的单点登录？

6. （可能会问）分布式锁怎么实现的？

# 权限项目

[基于这个](https://shuwoom.com/?p=3041)

## 简介

基于SpringBoot搭建的一个RBAC（Role-Based Access Control）——基于角色的访问控制系统，

RBAC通过定义角色的权限，并对用户授予某个角色从而来控制用户的权限。

能够根据角色分配权限。每个用户对应一个角色，一对一关系，每个角色有一些

![img](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\rbacrole-based-access-control-1.png)

![1](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\vIReQ3fevo3UUetTeKjP.png)

![2](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\aF62T8Yu9fZ7APgdK2Zf.png)

## 技术点

**RBAC（Role-Based Access Control）——基于角色的访问控制系统**

[原文](![rbac说明图](https://shuwoom.com/wp-content/uploads/2019/04/rbac-demo.png))

例如下图，管理员和普通用户被授予不同的权限，普通用户只能去修改和查看个人信息，而不能创建创建用户和冻结用户，而管理员由于被授予所有权限，所以可以做所有操作。

![rbac说明图](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\rbac-demo.png)

**RBAC支持的安全原则**

- 最小权限原则：RBAC可以将角色配置成其完成任务所需的最小权限集合
- 责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个计账员和财务管理员共同参与统一过账操作
- 数据抽象原则：可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读、写、执行权限



（1）优点：

- 简化了用户和权限的关系
- 易扩展、易维护

（2）缺点：

- RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统

### 1、RBAC的功能模块

![rbac功能模块](https://shuwoom.oss-cn-beijing.aliyuncs.com/RBAC%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD.png)

### 2、RBAC执行流程

![rbac执行流程](https://shuwoom.oss-cn-beijing.aliyuncs.com/RBAC%E6%B5%81%E7%A8%8B.png)

### 3、RBAC数据库设计

![rbac数据库设计](https://shuwoom.oss-cn-beijing.aliyuncs.com/rbac%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.png)

1. 自定义注解实现权限验证

   //使用到springSecurity的@PreAuthorize，将需要权限判断的方法上加上自定义的注解，

   ~~~Java
       /**
        * 获取用户列表
        */
       @PreAuthorize("@ss.hasPermi('system:user:list')")
       @GetMapping("/list")
       public TableDataInfo list(SysUser user)
       {
           startPage();
           List<SysUser> list = userService.selectUserList(user);
           return getDataTable(list);
       }
   ~~~

   还是使用拦截器，拦截请求，验证请求方法上的注解的权限信息，验证通过才放行

   

2. 用户分配角色完成权限分配

3. 操作日志

   

## 面试问题

1. 权限注解怎么实现的？
2. 登录验证怎么实现的？
3. redis里存什么？

# 陆金所项目

## 简单介绍



\1. 参与公司AI质量管理平台研发工作，基于Spring+SpringMVC+Mybatis开发，主要功能是员工信息管理

\2. 主要负责系统内日报周报模块以及工时录入模块开发工作，完成周报日报录入与查询功能

\3. 主要完成后端Java接口与VUE前端界面代码编写，参与项目模块的需求讨论，完成项目发版任务





一个内部员工管理平台，前后端分离的项目，后端SSM，前端VUE

前后端交互用json



## 技术点

## 面试问题



# 恒生项目

## 简介



\1. 参与公司估值产品工具开发，基于Spring+SpringMVC+Mybatis开发，主要功能是客户系统信息的记录管理

\2. 主要完成系统SSM环境配置，操作日志功能中注解与切面的开发，系统通用响应对象设计，业务接口开发

\3. 参与项目需求讨论，完成系统接口文档编写，系统功能接口测试以及项目部署工作

## 技术点

1. #### 各种网站攻击

   **CSRF（Cross Site Request Forgery** 攻击，一般被翻译为**跨站请求伪造**。说简单用你的身份去发送一些对你不友好的请求。

   Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。

   我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。

   需要注意的是不论是 Cookie 还是 token 都无法避免跨站脚本攻击（Cross Site Scripting）XSS。

   XSS中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如cookie。

2. #### token技术

   token译为令牌。

   只要 token 可以被客户端存储就能够使用，因此可用于移动端，而且 token 还可以跨语言使用。

   token一旦派发，就不会再更改。

   ## [Token 认证常见问题以及解决办法](https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT-advantages-and-disadvantages?id=token-认证常见问题以及解决办法)
   
   - 注销登录等场景下 token 还有效
   
     具体场景有：
   
     1. 退出登录;
     2. 修改密码;
     3. 服务端修改了某个用户具有的权限或者角色；
     4. 用户的帐户被删除/暂停。
     5. 用户由管理员注销；
   
   - 解决方式：
   
     ​	比较好的方式：**使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。**
   
3. #### JWT技术

   JWT（JSON Web Token）**本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。**
   
   [JWT 超详细分析](https://learnku.com/articles/17883?order_by=vote_count&)
   
   [Jwt生成token以及token过期校验](https://blog.csdn.net/duanduan339/article/details/103416390)
   
   [项目中使用的auth0进行的jwt加解密](https://www.jianshu.com/p/0fed399c2561)

​	JWT 最适合的场景是不需要服务端保存用户状态的场景。

   JWT由三部分组成：

​	一个 JWT token 是一个字符串，它由三部分组成，头部、载荷与签名，中间用 `.` 分隔，例如：`xxxxx.yyyyy.zzzzz`

   - Header：描述JWT的元数据。定义了生成签名的算法以及Token的类型。

     头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）

     ~~~java 
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     ~~~

     然后用 `Base64Url` 编码得到头部，即 `xxxxx`。

   - Payload(负载)：用于存放实际需要传递的数据。

     载荷的属性也分三类：

     - 预定义（Registered）
     - 公有（public）
     - 私有（private）

     **预定义的载荷**

     ~~~json
     {
       "sub": "1",
       "iss": "http://localhost:8000/auth/login",
       "iat": 1451888119,
       "exp": 1454516119,
       "nbf": 1451888119,
       "jti": "37c107e4609ddbcc9c096ea5ee76c667",
       "aud": "dev"
     }
     ~~~

     这里面的前 7 个字段都是由官方所定义的，也就是预定义（Registered claims）的，并不都是必需的。

     > iss (issuer)：签发人
     > sub (subject)：主题
     > aud (audience)：受众
     > exp (expiration time)：过期时间
     > nbf (Not Before)：生效时间，在此之前是无效的
     > iat (Issued At)：签发时间
     > jti (JWT ID)：编号

     

   - Signature(签名)：服务器通过Payload、Header和一个密钥（secret）使用Header里面指定的签名算法（默认是HMAC SHA256）生成。

     签名时需要用到前面编码过的两个字符串，如果以 `HMACSHA256` 加密，就如下：

     ~~~json
     HMACSHA256(
         base64UrlEncode(header) + "." +
         base64UrlEncode(payload),
         secret
     )
     ~~~

     加密后再进行 `base64url` 编码最后得到的字符串就是 `token` 的第三部分 `zzzzz`。

     组合便可以得到 `token：xxxxx.yyyyy.zzzzz`。

     **签名的作用：**保证 JWT 没有被篡改过，原理如下：

     >HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。
     >
     >**Hash-based Message Authentication Code**

        客户端将 `Token` 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：` Authorization: Bearer Token`。

     **JWT的优点：**

     1. 无状态
     
     2. 编码数据
     
        **注意：**
     
        （1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
     
        （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。
     
        （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
     
        （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
     
        （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
     
        （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

​	**token泄露怎么办？**

​				加密

​				设置较短的有效期

​				使用HTTPS传输

​	**项目中的使用方法：**

​	登录时生成token，token里设置了一个自定义的uuid，返回给浏览器。uuid与项目中自定义的字符串前缀拼接，作为key，将生成的token缓存到redis，并设置失效时间为30分钟。浏览器发请求时，拦截器进行方法拦截，验证方法上有没有我们自定义的注解，也就是有一个tokenrequired注解，表示需要进行token验证。做这个注解的目的是为了让登录请求不需要验证token。如果方法上有这个注解，就从token里拿到设置的uuid，再加上程序里设定的前缀吗，组合起来作为key去redis里读取token值，与传递来的token进行比较，相等就验证通过。否则验证失败。拦截器的prehadler方法返回true时会执行方法，返回false时不会执行方法。

4. #### Cookie技术

   **Cookie 的跨域策略**

   子可以读父，但是父不可以读子，兄弟之间不能互相访问。

   a.xxx.com 和 b.xxx.com 可以读 xxx.com，但是 a.xxx.com 和 b.xxx.com 不能互相读取，xxx.com 也不能读 a.xxx.com 和 b.xxx.com 的。

   

## 面试问题

1. token被劫持怎么办？-------------------------------------------------------------------------------------

   a、在存储的时候把 token 进行对称加密存储，用时解开。
   b、将请求 URL、时间戳、token 三者进行合并加盐签名，服务端校验有效性。。。。。。
   c、HTTPS 对 URL 进行判断。

2. JWT生成的token可以重写吗？可以设置过期时间吗？-------------

   一旦生成就不能修改。可以设置过期时间。

3. 响应对象里包含什么？

   见上面的分析