---
typora-copy-images-to: images
---

# Spring

## 对于 Spring IoC 和 AOP 的理解

**Spring IoC的初始化过程：**

![Spring IoC的初始化过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png)

[IOC源码阅读](https://javadoop.com/post/spring-ioc)

[AOP源码](https://javadoop.com/post/spring-aop-source)

## 启动IOC容器

~~~Java
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationfile.xml");
}
~~~

![1](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1.png)

## 启动过程分析

//todo

## BeanFactory与ApplicationContext

![2](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\2.png)

# AOP

代理模式很简单，接口 + 真实实现类 + 代理类，其中 真实实现类 和 代理类 都要实现接口，实例化的时候要使用代理类。所以，Spring AOP 需要做的是生成这么一个代理类，然后**替换掉**真实实现类来对外提供服务。

替换的过程怎么理解呢？在 Spring IOC 容器中非常容易实现，就是在 getBean(…) 的时候返回的实际上是代理类的实例，而这个代理类我们自己没写代码，它是 Spring 采用 JDK Proxy 或 CGLIB 动态生成的。

> getBean(…) 方法用于查找或实例化容器中的 bean，这也是为什么 **Spring AOP 只能作用于 Spring 容器中的 bean 的原因，对于不是使用 IOC 容器管理的对象，Spring AOP 是无能为力的。**

