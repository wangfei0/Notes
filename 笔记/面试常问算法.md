# 1. topK问题

> 拼多多面试问题
>
> 参考：https://www.jianshu.com/p/a4a1984fc4ff

**题目描述：**

无序数组找到top K大的元素？

**解决方法：**

使用堆排序，维护一个K个元素的小顶堆（如果是K个最小值就用大顶堆），依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中。遍历完全部数据，Top K 的元素也自然都在堆里面了。

对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。

**时间复杂度分析：**

整个操作中，遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，加起来就是 O(nlogK) 的复杂度，换个角度来看，如果 K 远小于 n 的话， O(nlogK) 其实就接近于 O(n) 了，甚至会更快，因此也是十分高效的。
**代码实现：**

维护小顶堆的代码

优先队列PriorityQueue实现(优先队列看这一篇https://www.jianshu.com/p/f1fd9b82cb72)

>PriorityQueue 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。
>PriorityQueue 队列的头指排序规则最小那哥元素。如果多个元素都是最小值则随机选一个。
>PriorityQueue 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节。
>
>1>PriorityQueue是一种无界的，线程不安全的队列
>2>PriorityQueue是一种通过数组实现的，并拥有优先级的队列
>3>PriorityQueue存储的元素要求必须是可比较的对象， 如果不是就必须明确指定比较器

~~~Java
public List<Integer> solutionByHeap(int[] input,int k){
    List<Integer> list = new ArrayList<>();
    if(k > input.length || k == 0){
        return list;
    }
    //优先队列
    Queue<Integer> queue = new PriorityQueue<>();
    for(int num:input){
        if(queue.size() < k){
            //构建小顶堆
            queue.add(num);
        }else if(queue.peek() < num){
            //比较堆顶元素和当前遍历到的元素的大小
            //如果堆顶元素小于当前遍历元素，抛弃堆顶，将此数加入堆，重新构建小顶堆，这样到最后堆里就是全部的K个最大值
            queue.poll();
            queue.add(num);
        }
    }
    //取出K个元素
    while( k-- > 0){
        list.add(queue.poll());
    }
    return list;
}
~~~

