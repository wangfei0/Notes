---
typora-copy-images-to: images
typora-root-url: images
---

# JVM

# JMM Java内存模型

Java内存模型（Java Memory Model, JMM）

## JVM的内存区域划分

![1604231199093](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1604231199093.png)

## 1. 方法区/元空间

存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码，jar包等

运行时常量池（Runtime Constant Pool）是方法区的一部分。存储编译期就生成的字面常量、符号引用、翻译出来的直接引用。

## 2. 堆（heap）

存放生成的对象。即new 出来的对象。

## 3. 程序计数器

[详细解释](https://blog.csdn.net/leaf_0303/article/details/78953669)

1. 如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址
2. 如果正在执行的是Native 方法，则这个技术器值为空（Undefined）
3. 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

![这里写图片描述](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\20180102170104381.png)

程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。

## 4. 虚拟机栈（stack）

- 虚拟机栈是执行Java方法的
- 一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame）
- 栈帧中存储的有局部变量表、操作栈、动态链接、方法出口
- 当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈

## 5. 本地方法栈

本地方法栈是用来执行native方法的。

## 直接内存

直接内存并不是JVM管理的内存。直接内存，就是 JVM以外的机器内存。比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存。

# 堆内存详细划分

1. 年轻代
   - Eden区
   - Survivor区
     		有两个
     - Survivor-from
     - Survivor-to
2. 老年代
   	Tenured/Old

# 对象在内存中的分配

[文章](https://blog.csdn.net/qq_30753945/article/details/54974899)

1. 堆内存中存放的是new出的对象，new出的对象只包含成员变量。也就是实例对象和数组
2. 栈内存中：存放的是局部成员变量。对于基本的数据类型存放的是基本变量的值，而对于对象变量，存放的是堆内存的地址。 
3. Java6和6之前，常量池是存放在方法区（永久代）中的。
   Java7，将常量池是存放到了堆的老年代中。
   Java8之后，取消了整个永久代区域，取而代之的是元空间。常量池依然存放在老年代中。

[另一篇文章]([https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_1-%e6%8f%ad%e5%bc%80-jvm-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6%e7%9a%84%e7%a5%9e%e7%a7%98%e9%9d%a2%e7%ba%b1](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM垃圾回收?id=_1-揭开-jvm-内存分配与回收的神秘面纱))

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

经过这次GC后，Eden区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到老年代中。

![1604233480783](/1604233480783.png)

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

# Java对象引用的类型

**强软弱虚**

1.  强引用（StrongReference）
	**垃圾回收器绝不会回收它**
2.  软引用（SoftReference）
    如果一个对象只具有软引用，那就类似于可有可无的生活用品。
    如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
    	**内存不足才回收**
3.  弱引用（WeakReference）
    弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。
    在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
    	**发现就回收**
4.  虚引用（PhantomReference）
    "虚引用"顾名思义，就是形同虚设
    如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
    	**任何时候都可能回收**

# 强制垃圾回收

1. System.gc() 
   	调用 System 类的 gc()静态方法
2. Runtime.getRuntime().gc() 
   	调用 Runtime 对象的 gc()实例方法

# GC（Garbage Collection）

## GC原理

当一个对象被创建时，GC开始监控这个对象的大小、内存地址及使用情况。在垃圾回收机制回收任何对象之前，总会先调用它的 finalize()方法

## 三种类型的GC

1. **Minor GC**

   	- 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存
      	- Eden 和 Survivor 区不存在内存碎片

   - 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC
     		比如当 Eden 区满了
   - 所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）
     		停止应用程序的线程
   - 每次 Minor GC 会清理年轻代的内存
   - 在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC

2. **Major GC过程**
   	Major GC 是清理永久代

3. **Full GC**

   - Full GC 是清理整个堆空间—包括年轻代和永久代
   - fullgc的触发条件
     		system.gc()
       		老年代被占满
       		直接分配老年代大对象失败
       		metaspace溢出
       		指发生在老年代的 GC，出现了 Major/full GC 经常会伴随至少一次的 Minor GC（并非绝对）

4. 元空间（方法区垃圾回收）
   	常量池中的常量，无用的类信息
      	没有引用了就可以被回收

## 如何判断一个类是无用的类
 	1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
 	2. 加载该类的 ClassLoader 已经被回收。
 	3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 判断对象是否是垃圾

### 1. 引用计数算法

### 2. 可达性分析算法

这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![1604232746267](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1604232746267.png)

**可作为GC Roots的对象：**

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象

## 垃圾回收算法

1. Serial收集器
	使用一个线程进行GC，其它工作线程暂停
		![1604235318366](/1604235318366.png)
	串行收集器
	新生代采用复制算法，老年代采用标记-整理算法
	
2. ParNew收集器
	Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停
		![1604235328704](/1604235328704.png)
	并行收集器
	新生代采用复制算法，老年代采用标记-整理算法
	
3. Parallel Scavenge 收集器
	新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间
	
4. Serial Old收集器
	老年代收集器，单线程收集器，使用标记整理
	
6. CMS（Concurrent Mark Sweep）收集器
	
	![1604235364893](/1604235364893.png)
	
	- 老年代收集器
	- 并行标记清除器
	- 标记-清除”算法
	- 致力于获取最短回收停顿时间，使用标记清除算法，多线程
	- 优点是并发收集（用户线程可以和GC线程同时工作），停顿小
	
	**CMS：**
	
	- 并发标记清除(CMS)
	- 主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求
	- 年老代的回收
	- 目标是尽量减少应用的暂停时间
	  		减少full gc发生的几率
	- 利用和应用程序线程并发的垃圾回收线程来标记清除年老代
	- 用两次短暂停来替代串行标记整理算法的长暂停
	- 先3次标记，再1次清除
- 并不是老年代满了才触发Full GC
	  		而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC
	  	收集周期
	
	**执行过程：**
	
1. 初始标记(CMS-initial-mark) 
				标记老年代中所有的GC Roots对象
				标记年轻代中活着的对象引用到的老年代的对象
	指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象
	
2. 并发标记(CMS-concurrent-mark) 
  与用户线程同时运行
  从“初始标记”阶段标记的对象开始找出所有存活的对象

  预清理（CMS-concurrent-preclean）
  与用户线程同时运行
    可被终止的预清理（CMS-concurrent-abortable-preclean）
     	与用户线程同时运行

4. 重新标记(CMS-remark)
    任务是完成标记整个年老代的所有的存活对象
    
      重新标记的内存范围是整个堆
      包含_young_gen和_old_gen
    
4. 并发清除(CMS-concurrent-sweep) 
       与用户线程同时运行
       这个阶段主要是清除那些没有标记的对象并且回收空间
                      由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”

5. 并发重设状态等待下次CMS的触发(CMS-concurrent-reset)

     ![1604235443847](/1604235443847.png)

     ​                 ​               1，5两个步骤需要暂停所有的应用程序线程

      ```
      内存碎片问题
      	CMS是基于标记-清除算法的，CMS只会删除无用对象，不会对内存做压缩，会造成内存碎片
      ```

3. G1
    G1![在这里插入图片描述](/20200923112518492.png)
    	Garbage First (G1)
    	G1的设计原则是"首先收集尽可能多的垃圾(Garbage First)"
    	以关注延迟为目标
    	工作流程
    		初始标记
    		并发标记
    		最终标记
    		筛选回收
    	G1采用内存分区(Region)的思路
    		将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收
    			存活的对象复制到另一个空闲分区中
    				由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；
    	G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
    	并发标记周期
    	与CMS的对比
    	发生FulGC的情况
    	XX:G1MixedGCCountTarget
    		mixgc的最大次数。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。
    			根据废物比和最大次数，选出最小的cset，然后多次mixgc后回收完毕
    	RSet
    		只存放跨区引用，如老年代引用了年轻代的对象，除掉扫描整个老年代带来的成本

# OOM

## 实现一个自己的OOM

[new 一个list，不断的往list里add元素](https://www.jianshu.com/p/fa11a56a2ce8)
new 一个list，不断的往list里add元素

## 哪里会发生OOM

按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM

## 什么情况下会发生OOM

1. **内存泄露**
   	申请的内存在被使用完后没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了
2. **内存溢出**
   	申请的内存超出了JVM能提供的内存大小
   		java 堆内存溢出
   			一般由于内存泄露或者堆的大小设置不当引起。
   		java 永久代溢出 ，即方法区溢出了
   			一般出现于大量Class 或者 jsp页面，或者采用cglib等反射机制的情况，
   			过多的常量，尤其是字符串，也会导致方法区溢出。
3. 不会抛OOM error，但也是比较常见的Java内存溢出
   	java.lang.StackOverflowError
   		JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。
   		可以通过虚拟机参数 -Xss 来设置栈的大小

## 常见类型

1. 堆内存溢出

   - Java堆用于存储对象实例
   - 一般由于内存泄露或者堆的大小设置不当引起
   - new 一个大对象
   - 不断地创建对象

2. 方法区溢出

   - 一般出现于大量Class或者jsp页面

   - 或者采用cglib等反射机制的情况

   上述情况会产生大量的Class信息存储于方法区

3. 栈内存溢出

   - 栈容量只能由-Xss参数设定
   - OutOfMemoryError
     	多线程下的内存溢出
     		虚拟机扩展时无法申请到足够的内存空间
     		与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出
   - StackOverFlow
     	递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度
     	线程申请的栈深度超过允许的最大深度

4. 本地直接内存溢出

   Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小

5. StackOverFlowError

   - 不会抛OOM error，但也是比较常见的Java内存溢出
   - JAVA虚拟机栈超出最大栈深度

# 类加载

## 加载过程

1. 加载

   1、通过类的全限定名来获取定义此类的二进制字节流
   2、将这个类字节流代表的静态存储结构转为方法区的运行时数据结构
   	在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。
   3、这个过程主要就是类加载器完成。（对于HotSpot虚拟而言，Class对象较为特殊，其被放置在方法区而不是堆中）

2. 验证

   一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。

3. 准备

   仅仅为类变量（static修饰的变量）分配内存空间并且设置该类变量的初始值（这里的初始值指的是数据类型默认的零值），这里不包含用final修饰的static，因为用final修饰的类变量在javac执行编译期间就会分配，同时要注意，这里不会为实例变量分配初始化。

4. 解析

   解析阶段主要是将常量池内的符号引用替换为直接引用的过程

5. 初始化

   这个阶段主要是对类变量初始化，是执行类构造器的过程。

## 双亲委派机制

双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。。

![img](/20140105211242593)

**loadClass()方法：**

1. 使用递归去加载，先递归调用parent.loadclass，然后如果都找不到，就调用根加载器。
2. 然后如果抛出异常，就调用findclass方法

自定义类加载器如果不想破坏双亲委派模型，只需要重写findclass方法，否则还要重写loadclass方法

**好处：**

首先一个web容器要做到应用之间的jar包隔离，也就是各个应用之间可以引用不同版本的同一个jar包，但是不同版本的同一个jar包的全限定名是一样的，所以如果使用默认的java类加载器，那么加载出来的都是同一个类。

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

**打破双亲委派机制的：**

tomcat类加载器（违背双亲委派机制）



​	**原理：**自定义类加载器，重写findclass方法，然后调用Class.forName中的带自定义加载器参数的重载方法，然后生成class对象后，调用他的newInstance方法

## 类加载器

**Bootstrap ClassLoader: 根类加载器**。称为引导 ( 也称为原始或根)类加载器，负责加载 Java 的核心类。JVM 的根类加载器并不是 Java 实现的。

**Extension ClassLoader: 扩展类加载器 。**

**AppClassLoader(应用程序类加载器)**面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

## 类加载过程安全吗

安全

**原因：**

类加载器的loadClass方法中是有Synchronized关键字修饰的

# JVM参数

1. Xms 初始堆大小

2. Xmx 最大堆大小（一般和初始堆大小设成一样）

   为什么设置成一样的？

   1.  **避免JVM在运行过程中向OS申请内存**
      
      如果二者不等，最开始的时候堆大小是Xms，随着heap内存消耗，jvm很有可能需要申请更大的空间直到Xmx；相似的，jvm在申请到Xmx空间时可能又用不了，这时会缩小jvm空间，这样，虽然可以动态调整jvm堆申请的大小，但是每一次调整都需要一定的系统开销（jvm与os之间）。但是，注意前提——生产环境，生产环境意味着一台机器或者一个容器只有一个服务，独占机器意味着没有必要调整jvm大小，直接分配Xmx就行了。否则每一次调整都可能会有开销。
      
   2. **延后启动后首次GC的发生时机** GC发生在内存达到Xms设置的大小。设置成一样大小可以延后第一次GC的时间。

   3. **减少启动初期的GC次数** 。在产环境的这一前提下，如果最开始堆大小是Xms，也意味着可能会有比较多的gc，影响性能。

3. Xmn（年轻代大小）

4. XX:MaxPermSize 持久代的最大值

5. Xss 堆栈大小 

6. -XX 

# JVM命令

- 首先要找到Java的pid ps -ef|grep java. lsof -i:端口号
- dump文件jmap -dump:format=b,file=filename pid
- jmap -heap pid可以查看堆的占用情况
- jhat可以直接看dump，生成一个网页。但是没鸟用
- jmap -histo:live pid |more 可以看存活对象的数量前几名
- jstat -gcutil pid 2000 5 可以看各个区的被占比和gc的次数和时间。2000和5代表每隔2000毫秒统计一次，共五次

# JVM优化步骤

第一步：评估垃圾回收对延迟的影响
第二步：系统的对响应时间的需求
第三步：改善young代的大小
第四步：改善old代大小
第五步：上述方法还是不行，就要考虑使用CMS了
第六步：survivor区大小的抉择以及分代年龄的设置
第七步：调整CMS垃圾回收的周期

**JVM的堆内存不要超过32GB，原因。指针压缩**

指针压缩技术在对象头中的使用要注意。32位情况下class指针的大小是4字节，markword的大小是4字节。64位情况下翻倍。开启指针压缩后，class对象会减小，但是markword还是8字节