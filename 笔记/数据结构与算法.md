---
typora-copy-images-to: images
---

# 算法

## 排序算法

[十大排序图解](https://www.cnblogs.com/fivestudy/p/10212306.html)

![](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\排序时间复杂度.jpg)

#### 关于时间复杂度：

1. 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。
2. 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；
3. O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序
4. 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

#### 关于稳定性：

1. 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。
2. 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。



### 1. 冒泡排序

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-fafcf49997d511ee.gif)

~~~java 
    /**
     * 每次比较相邻的两个数字，
     * 从前往后比较，如果前一个数比后一个数大，就交换位置
     * 否则不交换位置
     *
     * 第一次确定最大的数
     *
     * @param array
     * @return
     */
    public static void bubbleSort1(int[] array) {
        for (int i = 0; i < array.length; i++) {
            //flag记录每一次是不是交换了位置，如果没有交换就是说明数组已经有序，可以结束了
            boolean flag = false;
            for (int j = 0; j < array.length-i-1; j++) {
                if (array[j+1]<array[j]){
                    //后一个数比前一个数小，交换位置
                    int tmp = array[j+1];
                    array[j+1] = array[j];
                    array[j] = tmp;
                    flag = true;
                }
            }
            if (!flag) break;
        }
    }
~~~

### 2. 选择排序

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-b69f69ee21073f80.gif)

~~~Java
    /**
     * 选择排序
     * @param array
     * @return
     */
    public static int[] selectionSort(int[] array) {
        if (array.length == 0)
            return array;
        for (int i = 0; i < array.length; i++) {
            int minIndex = i;
            for (int j = i; j < array.length; j++) {
                if (array[j] < array[minIndex]) //找到最小的数
                    minIndex = j; //将最小数的索引保存
            }
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
        return array;
    }
~~~



### 3. 插入排序

- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

  ![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-9455ff13bc8fbdc6.gif)

  ~~~Java
      /**
       * 插入排序
       *
       * @param array
       * @return
       */
      public static int[] insertionSort(int[] array) {
          if (array.length == 0) {
              return array;
          }
          for (int i = 0; i < array.length - 1; i++) {
              int current = array[i + 1];
              int preIndex = i;
              while (preIndex >= 0 && current < array[preIndex]) {
                  array[preIndex+1] = array[preIndex];
                  preIndex--;
              }
              array[preIndex+1]=current;
          }
          return array;
      }
  ~~~

  

### 4. 希尔排序

**缩小增量插入排序**

- 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
- 按增量序列个数 k，对序列进行 k 趟排序；
- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-acc6c6f16b096794.gif)

~~~Java
    /**
     * 希尔排序
     *
     * @param array
     * @return
     */
    public static int[] ShellSort(int[] array) {
        int len = array.length;
        int gap = len / 2, temp;
        while (gap > 0) {
            for (int i = gap; i < len; i++) {
                temp = array[i];
                int perIndex = i - gap;
                while (perIndex >= 0 && array[perIndex] > temp) {
                    array[perIndex + gap] = array[perIndex];
                    perIndex -= gap;
                }
                array[perIndex + gap] = temp;
            }
            gap /= 2;
        }
        return array;
    }
~~~



### 5. 归并排序

- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
- 重复步骤 3 直到某一指针达到序列尾；
- 将另一序列剩下的所有元素直接复制到合并序列尾。

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-d3d400686bc61c30.gif)

~~~Java
    private int[] mergeSort(int[] nums, int left, int right) {  // 需要左右边界确定排序范围
        if (left >= right) return nums;
        int mid = (left+right) / 2;

        mergeSort(nums, left, mid);                           // 先对左右子数组进行排序
        mergeSort(nums, mid+1, right);

        int[] temp = new int[right-left+1];                   // 临时数组存放合并结果
        int i=left,j=mid+1;
        int cur = 0;
        while (i<=mid&&j<=right) {                            // 开始合并数组
            if (nums[i]<=nums[j]) temp[cur] = nums[i++];
            else temp[cur] = nums[j++];
            cur++;
        }
        while (i<=mid) temp[cur++] = nums[i++];
        while (j<=right) temp[cur++] = nums[j++];

        for (int k = 0; k < temp.length; k++) {             // 合并数组完成，拷贝到原来的数组中
            nums[left+k] = temp[k];
        }
        return nums;
    }
~~~



### 6. 快速排序

- 从数列中挑出一个元素，称为 “基准”（pivot）;
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-6d01faf07a21e730.gif)

~~~Java
    /**
     * 快速排序
     * @param nums
     * @param left
     * @param right
     */
    public static void quickSort(int[] nums, int left, int right){
        if (left >= right){
            return;
        }
        int low = left;
        int height = right;
        int pivot = nums[left];
        while (left < right){
            while (left < right && nums[right] > pivot){
                right--;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] < pivot){
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        quickSort(nums,low,left-1);
        quickSort(nums,left+1,height);
    }
~~~



### 7. 堆排序

- 创建一个堆 H[0……n-1]；
- 把堆首（最大值）和堆尾互换；
- 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
- 重复步骤 2，直到堆的尺寸为 1。

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-047a907d162a4a0b.gif)

### 8. 计数排序

- 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max
- 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)
- 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数
- 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-ea11a52dedaf0795.gif)

~~~Java
    public static void countSort(int[] arr){
        int len = arr.length;
        //先找出最大值和最小值
        int min = arr[0];
        int max = arr[0];
        for (int i = 0; i < len; i++) {
            max = Math.max(max,arr[i]);
            min = Math.min(min,arr[i]);
        }
        //定义一个长度为lenTmp的数组
        int lenTmp = max-min+1;
        int[] tmp = new int[lenTmp];
        //计数
        for (int i = 0; i < len; i++) {
            //这里的下标其实是与最小值的差
            tmp[arr[i]-min]++;
        }
        //回填数组,按照出现的次数回填
        int k = 0;
        for (int i = 0; i < lenTmp; i++) {
            for (int j = 1; j <= tmp[i]; j++) {
                arr[k++] = i+min;
            }
        }
    }
~~~



### 9. 桶排序

- 设置固定数量的空桶。
- 把数据放到对应的桶中。
- 对每个不为空的桶中数据进行排序。
- 拼接不为空的桶中数据，得到结果

![img](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\20190107115253.gif)

### 10. 基数排序

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
- 从最低位开始，依次进行一次排序
- 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

![image](D:\JAVA\JAVA_Stady_Project\简历与笔记\程序员的套路分库\images\1940317-f795324456e5717d.gif)

~~~Java

~~~





# 数据结构

## 红黑树

